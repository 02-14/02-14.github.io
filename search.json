[{"url":"/post/0.html","content":"《Cross-Attention is All You Need》Gheini 等人的研究明确指出，在对预训练模型进行迁移学习以适应新语言对时，交叉注意力参数的更新比自注意力参数更为关键 。交叉注意力微调策略的一个衍生深度洞察是，它能够强制模型在保持主体冻结的情况下实现嵌入向量的跨语言对齐。\n《Bridging the Language Gaps in Large Language Models with Inference-Time Cross-Lingual Intervention》针对解码器（Decoder-only）架构的 LLM，Wang 等人提出的 INCLINE 框架则更进一步，将对齐过程从训练阶段推向了推理阶段 。这种方法不需要修改模型的权重，而是通过在推理时动态注入干预向量，将低表现语言（源语言）的隐藏状态“拨正”到高表现语言（目标语言，通常为英语）的表示空间中 。\n《Neural Machine Translation by Jointly Learning to Align and Translate》这篇文章针对传统“编码器-解码器”架构将源句强制压缩为固定长度向量所导致的性能瓶颈（尤其是长句翻译质量劣化），提出了一种能够联合学习对齐与翻译的新型神经机器翻译架构。该模型的核心贡献在于首次引入了注意力机制（Attention Mechanism）：它放弃了单一向量表示，而是利用双向RNN（BiRNN）编码器将源句转换为一系列包含上下文信息的“注释向量”。在解码阶段，解码器不再被动接收信息，而是通过一个对齐模型主动计算当前目标词与各个输入注释向量之间的相关性，从而生成软对齐（Soft-alignment）**权重，并以此构建动态的“上下文向量”来辅助翻译。这种机制允许模型在生成每个词时自适应地“关注”源句中最相关的部分，不仅在英法翻译任务中显著提升了长句的处理能力，还通过可视化的对齐矩阵证明了模型能够捕捉到语言学上合理的对应关系，为后来深度学习领域注意力机制的大规模应用奠定了基础。\n《Attention Is All You Need》这篇文章提出了Transformer模型，一种完全基于注意力机制的序列到序列建模架构，首次在机器翻译等任务中彻底摒弃了循环神经网络（RNN）和卷积结构。通过引入自注意力机制（Self-Attention）和多头注意力（Multi-Head Attention），使模型能够在常数级路径长度内建模任意位置之间的依赖关系，从而显著提升并行计算能力并降低训练时间。Transformer 采用编码器—解码器结构，每一层由注意力子层和前馈网络组成，并结合残差连接、层归一化与位置编码来弥补序列顺序信息的缺失。实验结果表明，该模型在 WMT 2014 英德和英法翻译任务上取得了当时的最优 BLEU 分数，同时训练成本远低于传统模型，并且在句法分析等其他任务上同样表现出良好的泛化能力。整体而言，文章证明了“注意力机制本身即可完成序列建模”，为后续大规模预训练语言模型奠定了基础。介绍了 cross-attention，但没有单独用这个名字，而是称之为 Encoder-Decoder Attention。在论文中，cross-attention 出现在 Transformer 解码器（Decoder）中的第三个子层。其核心思想是：Query（Q）来自解码器当前层的隐藏状态，Key（K）和 Value（V）来自编码器的输出表示，从而使解码器在生成每个目标词时，都可以对整个输入序列进行有选择的关注。将注意力机制分为三种使用方式：Encoder Self-Attention（编码器内部的自注意力）Decoder Self-Attention（带掩码的解码器自注意力）Encoder-Decoder Attention（即 Cross-Attention）\n《Paying More Attention to Source Context: Mitigating Unfaithful Translations from Large Language Model》这篇论文的核心贡献在于系统性地揭示并缓解了 decoder-only 大语言模型在机器翻译中因过度依赖目标前缀而产生不忠实（hallucinated）翻译的问题。作者首先通过贡献度（contribution）分析，对生成过程中不同输入 token（源句与已生成目标前缀）对当前输出的影响进行可解释量化，实证表明主流 LLM 在翻译时往往更多依赖目标前缀而非源上下文，这是不忠实翻译的重要成因。在此基础上，论文提出了三类互补的方法来重新平衡“源—目标”依赖关系：其一，源上下文重加权注意力（Reweight Attention），通过显式构造对齐锚点并在注意力 logits 中对其邻域施加高斯型增强，使模型在推理阶段更集中地关注与当前生成位置相关的源 token；其二，基于最大互信息的对比式解码（Contrastive &#x2F; MMI Decoding），在不修改模型参数的情况下，通过惩罚仅由目标前缀即可高概率生成的 token，抑制语言模型惯性、强化对源输入的依赖；其三，目标约束指令微调（Target-constrained Instruction Tuning），在监督微调阶段通过随机掩码目标前缀并引入双向 KL 正则，使模型在训练中学会在目标信息不完整时仍依赖源句进行生成。实验结果表明，这些方法在零样本与微调设置下均能显著降低翻译幻觉、提升 BLEU 和 COMET 等指标，并在人类评估中减少不忠实翻译比例。整体而言，本文的贡献不仅在于提出了一套可解释的诊断工具（贡献分析），更在于提供了无需结构改动、可在推理或训练阶段灵活应用的对齐与注意力增强方案，为提升 LLM 翻译忠实性提供了通用而实用的思路。\n《Mitigating Hallucinated Translations in Large Language Models with Hallucination-focused Preference Optimization》这篇论文提出了一种面向幻觉的偏好优化方法来降低大语言模型在机器翻译中的幻觉问题，其核心思想是：不依赖人工标注，而是自动发现、自动修正、再用偏好学习“教会模型避开幻觉”。具体做法是先让模型翻译大规模单语数据，用无参考质量评估模型（BLASER-QE）检测与源句严重不一致的译文作为“幻觉样本”，再通过后处理采样与重排序生成对应的“无幻觉替代译文”，从而构造（好译文 vs 坏译文）的偏好对；随后在对比偏好优化（CPO）框架下联合使用监督似然损失和偏好损失进行微调，并用“幻觉严重度”作为权重强化学习信号。论文的主要贡献在于：提出了一条可扩展、无监督的幻觉偏好数据构建流水线，将幻觉缓解从推理阶段的后处理转移到训练阶段；并实证表明该方法能在多语言翻译中显著降低幻觉率（最高减少约 96%），同时通过混合训练基本保持翻译质量。对于幻觉本身，论文指出其多表现为异常重复和无关扩展，译文往往显著长于源句，且容易被特定源句形式（如 URL、引号、全大写文本）触发；此外，幻觉具有语言对和模型相关性，说明其并非纯粹的数据噪声，而是模型生成机制中的系统性问题，因而需要通过训练目标而非简单解码约束来解决。\n《FiLM: Visual Reasoning with a General Conditioning Layer》\ncross-attention 通过以 decoder 状态为 Query、以 src 表示为 Key&#x2F;Value，使生成过程在每一步显式地条件化于源序列，从而增强生成 token 与 src 之间的对齐关系，避免模型仅依赖自身历史上下文。\n在建模历史 token 的同时，引入一个来自 src 的对齐约束信号,防止模型在生成过程中仅依赖自身历史 token，而忽略源序列语义\nFiLM（Feature-wise Linear Modulation）通过从源序列中预测缩放系数（γ）和偏置（β），对中间特征进行逐通道调制，从而将源端语义以参数化方式注入到生成网络中，实现更细粒度的条件控制。\n\nSelf-Attention → 建模目标端语言结构（流畅性）\nCross-Attention → 建立 src–tgt 对齐（语义映射）\nFiLM → 从 src 提取控制信号，调制中间表示（条件强化）\nFFN → 非线性特征变换\n\n📌 Cross-attention &#x3D; 显式对齐 📌 FiLM &#x3D; 隐式调制\n模型首先通过 masked self-attention 建模已生成 token 之间的依赖关系。随后引入一个基于源序列的条件注意力模块(cross-attention )，使生成过程在每一步都能够访问源端语义表示，从而避免模型仅依赖自身历史上下文。在此基础上，FiLM 模块从源序列中学习特征调制信号，对中间表示进行逐通道缩放和平移，实现对生成过程的细粒度条件控制。最后通过前馈网络进行非线性特征变换。\ncross-attention只是token-level 的源–目标对齐，对于全局语义的理解不足，FiLM是feature-level的，可以提供全局的源语言语义约束，防止语义偏离\nFiLM（Feature-wise Linear Modulation） 是一种 条件化机制（conditioning mechanism），通过对中间特征进行逐通道的线性调制，将外部条件信息（如源序列 src）注入到神经网络中。\\\n\nγ 控制每个特征通道的幅度\n\n本质是对 embedding 空间的 非均匀拉伸 / 压缩\n\n语义层面的作用\n\n在 LLM 中：\n\n- 某些通道更偏向语法 / 流畅性\n- 某些通道更偏向语义内容 / 对齐\n- 某些通道更偏向风格 / 时态\n\nγ 可以：\n\n- 放大与 src 相关的语义方向\n- 抑制 decoder 自回归惯性方向\n- ```  β 改变特征的基线位置    改变激活阈值    和 FFN / 非线性强相关    β 可以：    决定哪些通道进入激活区    打开 / 关闭某些语义路径  这是条件 gating的一种形式\n\n\n\n$$FiLM(h)&#x3D;γ⊙h+β$$h：中间特征表示\nγ、β：由条件输入（如 src）预测的调制参数γ、β是通过从src中进行学习得到的缩放、平移参数，提供这个参数来对每个 token 做逐通道调制\n每一个维度（embedding维度） ≈ 一个语义通道：（每个维度都代表着语义空间中的一个潜在特征）\n某些维度更偏向语法\n某些维度更偏向词汇\n某些维度更偏向时态 &#x2F; 语气\n逐通道调制 &#x3D; 不同旋钮不同力度地拧\n⊙：逐元素乘法$$h\\in \\mathbb{R} ^{B\\times T\\times D}$$FiLM 的计算流程：\n从 src 中提取条件表示$$c&#x3D;f_{cond​} (src)$$预测调制参数$$γ&#x3D;W_{γ} ​c+b_{γ​}$$\n$$β&#x3D;W_{β​} c+b_{β​}$$\n$$γ,β∈R^{B×D}$$\n特征调制（广播到时间维）$$\\widetilde{h} {b,t,d​} &#x3D;γ{b,d​} ⋅h_{b,t,d} ​+β_{b,d​}$$逐 batch、逐通道、对所有 token 共享\n"},{"title":"词句摘要","url":"/post/3a87c6e8.html","content":"Large Language Models (LLMs) have shown remarkable capabilities in XXXXXLLMs在某些方面/领域展现出卓越的能力significant performance显著的性能表现exhibit 展览/展现among different language不同语言之间gaps/disparities差距Most existing approaches大多数现有的方法Recent approaches近期的研究方法rely on pretraining or fine-tuning依赖于预训练或微调To overcome these limitations为了克服这些局限性XXX by aligning YYY将XXX与YYY进行对齐alignment matrices对齐矩阵a variety of各种的state-of-the-art最先进的    is formulated as被建模为Our detailed analysis indicates that我们的详细分析表明translating monolingual text翻译单语文本heavily rely on严重依赖于    attempts to build试图构建belong to属于be jointly trained to maximize联合训练以最大化Most of the proposed大多数已提出的A potential issue with一个潜在问题In order to address this issue为了解决这个问题To tackle this issue为了解决这个问题Despite being a quite new approach尽管这是一个相当新的方法a soft alignment软对齐emergent abilities in machine translation (MT) 在机器翻译领域的新兴能力have also garnered significant attention引起广泛的关注\n\n"},{"title":"Hexo搭建","url":"/post/57ee7c1d.html","content":"先安装node.js(LTS)版本\n然后安装 git bash\n创建一个目录存放博客，例 F:/blog\n在目录下右键启动git bash\n安装Hexo ，在git bash输入npm install hexo-cli -g\n输入 hexo init 初始化博客\n输入hexo g 生成静态文件\n输入hexo s部署到本地，连接既是地址，可以查看\n在git bash命令窗口下按Ctrl+C可退出本地部署\n使用butterfly主题\n安装依赖 npm install hexo-renderer-pug hexo-renderer-stylus\n下载butterfly主题 git clone -b master https://github.com/jerryc127/hexo-theme-butterfly.git themes/butterfly\nblog/themes目录下会出现一个butterfly文件夹，说明主题下载成功\n打开blog目录下的_config.yml配置文件\n更改主题为butterfly\ntheme: butterfly\n\n清理缓存hexo clean\n生成静态文件 hexo g\n部署到本地 hexo s\n部署成功\n部署到 Github\n安装插件 npm install hexo-deployer-git --save\n打开 Github主页 点击 右上角+的 New repository新建仓库\n输入仓库名，这里要特别注意，仓库名一定要按照以下格式： 你的github用户名.github.io\n然后点击 Create repository创建仓库，会进入一个页面有一个 HTTPS or SSH点击 HTTPS将后面的链接复制\n打开blog的配置文件_config.yml，在deploy下输入以下内容：\ndeploy:  type: &#x27;git&#x27;  repo: 链接复制到这里  branch: main\n\n在git bash命令行窗口依次输入以下命令，部署到GitHub\nhexo clean hexo g\n去 GitHub 生成 Token（只做一次）打开 GitHub → 头像 → Settings左侧 → Developer settings→ Personal access tokens→ Tokens (classic)点 Generate new token (classic)勾选权限 repo（必须）设置：Expiration：No expiration（省事）Note：hexo-deploy生成后立刻复制保存token只会出现一次\n\nhexo d会弹出登录选择 token登录 Password：刚才生成的 Token\n再执行一次 hexo d\n会在仓库中建立 main分支用于存放内容\n"}]